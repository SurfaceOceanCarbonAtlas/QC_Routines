package uk.ac.exeter.QCRoutines.routines;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import uk.ac.exeter.QCRoutines.config.ColumnConfig;
import uk.ac.exeter.QCRoutines.data.DataRecord;
import uk.ac.exeter.QCRoutines.data.DataRecordException;
import uk.ac.exeter.QCRoutines.messages.Message;

/**
 * The base class for a QC routine. These classes will be called
 * to check the data after it's been read and processed for missing/
 * out of range values.
 */
public abstract class Routine {

	/**
	 * The configured parameters for the routine. May contain placeholders for dynamic parameters,
	 * which will be replaced at runtime.
	 */
	private List<String> configuredParameters = null;

	/**
	 * The column configuration for the expected data records
	 */
	protected ColumnConfig columnConfig = null;

	/**
	 * The list of error/warning messages generated by this checker
	 */
	private List<Message> messages;

	/**
	 * Base constructor - initialises the message list
	 */
	public Routine() {
		messages = new ArrayList<Message>();
	}

	/**
	 * Initialise the checker with its parameters and the configuration for the expected data format
	 * @param parameters The parameters for the routine
	 * @param columnConfig The column configuration for the data records
	 * @throws RoutineException If the parameters or column configuration are null
	 */
	public final void initialise(List<String> parameters, ColumnConfig columnConfig) throws RoutineException {

		if (null == parameters) {
			throw new RoutineException("Attempted to initialise routine with null parameters");
		}

		if (null == columnConfig) {
			throw new RoutineException("Attempted to initialise routine with null column configuration");
		}

		this.configuredParameters = parameters;
		this.columnConfig = columnConfig;
	}

	/**
	 * Pre-process parameters for the routine and make sure they are valid. Invalid
	 * parameters will cause an exception to be thrown. Routines have access
	 * to the column configuration through the {@link #columnConfig} field.
	 *
	 * @param parameters The parameters to check.
	 * @throws RoutineException If any parameters are invalid
	 */
	protected abstract void processParameters(List<String> parameters) throws RoutineException;

	/**
	 * Process a set of data records. Any dynamic parameters must be passed in as a map of
	 * {@code <parameterName, value>}.
	 *
	 * <p>
	 *   This method checks that the dynamic parameters match those required by
	 *   the routine's configuration, and then checks that the parameters are valid
	 *   using the {@link #processParameters(List)} method. Assuming those
	 *   checks pass, the actual processing is performed by the
	 *   {@link #processRecords(List, Map)} method.
	 * </p>
	 *
	 * @param records The records to be processed
	 * @param dynamicParameters The dynamic parameters for the routine
	 * @throws RoutineException If an error occurs during processing
	 */
	public final void processRecords(List<DataRecord> records, Map<String, String> dynamicParameters) throws RoutineException {

		// Check that the routine has been initialised
		if (null == configuredParameters || null == columnConfig) {
			throw new RoutineException("Routine not initialised.");
		}

		// Fill in the dynamic parameters
		List<String> concreteParameters = generateConcreteParameters(dynamicParameters);

		// Check that all parameters are valid
		processParameters(concreteParameters);

		// Process the records
		doRecordProcessing(records);
	}

	/**
	 * Perform the actual routine processing. Dynamic parameters will have been replaced
	 * by their concrete values by this point.
	 * @param records The records to be processed
	 * @throws RoutineException If an error occurs during processing
	 */
	protected abstract void doRecordProcessing(List<DataRecord> records) throws RoutineException;

	/**
	 * Returns the list of messages generated by this checker
	 * @return The list of messages generated by this checker
	 */
	public List<Message> getMessages() {
		return messages;
	}

	/**
	 * Add a message to the outcome of this routine. The message is also added
	 * to the data record that is being processed.
	 * @param message The message
	 * @param record The data record being processed
	 * @throws DataRecordException Only thrown if the Data Record is internally misconfigured
	 */
	public void addMessage(Message message, DataRecord record) throws DataRecordException {
		messages.add(message);
		record.addMessage(message);
	}

	/**
	 * A dynamic parameter starts with a % symbol, and is filled in
	 * at runtime by the method that runs the routine.
	 * @param parameter The parameter to be checked
	 * @return {@code true} if the parameter is dynamic; {@code false} if it is fixed.
	 */
	protected final boolean isDynamicParameter(String parameter) {
		return parameter.startsWith("%");
	}

	/**
	 * Generate a complete set of parameters using the
	 * configured parameters and the supplied dynamic parameter values
	 * @param dynamicParameters The dynamic parameters
	 * @return The concrete set of parameters
	 * @throws RoutineException If any required dynamic parameters are missing
	 */
	private List<String> generateConcreteParameters(Map<String, String> dynamicParameters) throws RoutineException {

		List<String> concreteParameters = new ArrayList<String>(configuredParameters.size());

		for (String parameter : configuredParameters) {
			if (!isDynamicParameter(parameter)) {
				concreteParameters.add(parameter);
			} else {
				// String off the leading %
				String parameterName = parameter.substring(1);
				if (null == dynamicParameters || !dynamicParameters.containsKey(parameterName)) {
					throw new RoutineException("Missing dynamic parameter '"+ parameterName + "'");
				} else {
					concreteParameters.add(dynamicParameters.get(parameterName));
				}
			}
		}

		return concreteParameters;
	}

	/**
	 * Get the list of dynamic parameters required by this routine
	 * @return The required dynamic parameters
	 * @throws RoutineException If the routine has not been initialised
	 */
	public final List<String> getRequiredDynamicParameters() throws RoutineException {
		List<String> dynamicParameters = new ArrayList<String>();

		if (null == configuredParameters) {
			throw new RoutineException("Routine not initialised");
		}

		for (String parameter : configuredParameters) {
			if (isDynamicParameter(parameter)) {
				dynamicParameters.add(parameter.substring(1));
			}
		}

		return dynamicParameters;
	}

	/**
	 * Each routine generates messages of a specific class. This method
	 * specifies that class
	 * @return The message class used by this routine
	 */
	public abstract Class<? extends Message> getMessageClass();
}
