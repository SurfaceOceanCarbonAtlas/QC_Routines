package uk.ac.exeter.QCRoutines.messages;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TreeSet;

/**
 * Messages generated by QC routines can be stored as code strings for easy storage in
 * databases etc.
 * <p>
 *   Each string consists of seven fields separated by underscores. The fields are: 
 * </p>
 * <ol>
 *   <li>
 *     The fully qualified class name of the message object
 *   </li>
 *   <li>
 *     The line number for which the message was raised
 *   </li>
 *   <li>
 *     The index of the column for which the message was raised.
 *     Can contain multiple indices, separated by the pipe (|) character.
 *   </li>
 *   <li>
 *     The name of the column for which the message was raised
 *     Can contain multiple names, separated by the pipe (|) character.
 *   </li>
 *   <li>
 *     The numerical value for the message's flag
 *   </li>
 *   <li>
 *     The field value in the record
 *   </li>
 *   <li>
 *     The valid value(s) that should have been in the record
 *   </li>
 * </ol>
 * @author Steve Jones
 * @see Message
 * @see Flag
 */
public class RebuildCode {
	
	/**
	 * The position of the class name in the code string
	 */
	private static final int CODE_INDEX_CLASS_NAME = 0;
	
	/**
	 * The position of the line number in the code string
	 */
	private static final int CODE_INDEX_LINE_NUMBER = 1;
	
	/**
	 * The position of the column index(es) in the code string
	 */
	private static final int CODE_INDEX_COLUMN_INDEX = 2;
	
	/**
	 * The position of the column name(s) in the code string
	 */
	private static final int CODE_INDEX_COLUMN_NAME = 3;
	
	/**
	 * The position of the flag value in the code string
	 */
	private static final int CODE_INDEX_FLAG_VALUE = 4;
	
	/**
	 * The position of the field value in the code string
	 */
	private static final int CODE_INDEX_FIELD_VALUE = 5;
	
	/**
	 * The position of the valid field value(s) in the code string
	 */
	private static final int CODE_INDEX_VALID_VALUE = 6;

	/**
	 * The message class
	 */
	private Class<? extends Message> messageClass;
	
	/**
	 * The line number
	 */
	private long lineNumber;
	
	/**
	 * The column indices
	 */
	private TreeSet<Integer> columnIndices;
	
	/**
	 * The column names
	 */
	private TreeSet<String> columnNames;
	
	/**
	 * The flag value
	 */
	private int flagValue;
	
	/**
	 * The field value
	 */
	private String fieldValue;
	
	/**
	 * The valid field value(s)
	 */
	private String validValue;
	
	/**
	 * Construct a rebuild code from a Message object
	 * @param message The message
	 * @throws MessageException If the Message object cannot be reconstructed from a rebuild code
	 */
	public RebuildCode(Message message) throws MessageException {
		messageClass = message.getClass();
		lineNumber = message.getLineNumber();
		columnIndices = message.getColumnIndices();
		columnNames = message.getColumnNames();
		flagValue = message.getFlag().getFlagValue();
		fieldValue = message.getFieldValue();
		validValue = message.getValidValue();
		
		Message.checkBasicConstructor(messageClass);
	}
	
	/**
	 * Parse a rebuild code string into an object that can in turn
	 * be converted back to a Message object.
	 * @param code The rebuild code
	 * @throws RebuildCodeException If the code cannot be parsed
	 */
	@SuppressWarnings("unchecked")
	public RebuildCode(String code) throws RebuildCodeException {

		List<String> codeComponents = extractComponents(code);
		if (codeComponents.size() != 7) {
			throw new RebuildCodeException("Incorrect number of elements");
		} else {
			
			try {
				messageClass = (Class<? extends Message>) Class.forName(codeComponents.get(CODE_INDEX_CLASS_NAME));
			} catch (ClassNotFoundException e) {
				throw new RebuildCodeException("Cannot find message class '" + codeComponents.get(CODE_INDEX_CLASS_NAME) + "'");
			}
			
			try {
				lineNumber = Long.parseLong(codeComponents.get(CODE_INDEX_LINE_NUMBER));
				if (lineNumber < 1) {
					throw new RebuildCodeException("Invalid line number");
				}
			} catch (NumberFormatException e) {
				throw new RebuildCodeException("Unparseable line number value");
			}
			
			try {
				columnIndices = new TreeSet<Integer>();
				
				String[] indices = codeComponents.get(CODE_INDEX_COLUMN_INDEX).split("\\|");
				for (String indexString : indices) {
					int columnIndex = Integer.parseInt(indexString);
					if (columnIndex < 0 && columnIndex != Message.NO_COLUMN_INDEX) {
						throw new RebuildCodeException("Invalid column index value");
					}

					columnIndices.add(columnIndex);
				}
				
			} catch (NumberFormatException e) {
				throw new RebuildCodeException("Unparseable column index value");
			}
			
			if (codeComponents.get(CODE_INDEX_COLUMN_NAME).length() == 0) {
				columnNames = new TreeSet<String>();
				for (int i = 0; i < columnIndices.size(); i++) {
					columnNames.add("");
				}	
			} else {
				columnNames = new TreeSet<String>(Arrays.asList(codeComponents.get(CODE_INDEX_COLUMN_NAME).split("\\|")));
			}
			
			try {
				flagValue = Integer.parseInt(codeComponents.get(CODE_INDEX_FLAG_VALUE));
				if (!Flag.isValidFlagValue(flagValue)) {
					throw new RebuildCodeException("Invalid flag value");
				}
			} catch (NumberFormatException e) {
				throw new RebuildCodeException("Unparseable flag value");
			}
			
			fieldValue = codeComponents.get(CODE_INDEX_FIELD_VALUE);
			validValue = codeComponents.get(CODE_INDEX_VALID_VALUE);
		}
	}
	
	/**
	 * Get the code string for this rebuild code
	 * @return The code string
	 */
	public String getCode() {
		StringBuffer result = new StringBuffer();
		result.append(messageClass.getName());
		result.append('_');
		result.append(lineNumber);
		result.append('_');
		
		int indexCount = 0;
		for (int columnIndex : columnIndices) {
			indexCount++;
			result.append(columnIndex);
			if (indexCount < columnIndices.size()) {
				result.append('|');
			}
		}
		
		result.append('_');

		int nameCount = 0;
		for (String columnName : columnNames) {
			nameCount++;
			result.append(columnName.replaceAll("_", "\\\\_")); // Escape underscores in column names
			if (nameCount < columnNames.size()) {
				result.append('|');
			}
		}
		
		result.append('_');
		result.append(flagValue);
		result.append('_');
		result.append(fieldValue);
		result.append('_');
		result.append(validValue);
		result.append(';');
		
		return result.toString();
	}
	
	@Override
	public String toString() {
		return getCode();
	}
	
	/**
	 * Rebuild the original Message object
	 * @return The Message object
	 * @throws MessageException If the Message object cannot be created
	 */
	public Message getMessage() throws MessageException {
		try {
			Constructor<?> messageConstructor = messageClass.getConstructor(long.class, TreeSet.class, TreeSet.class, Flag.class, String.class, String.class);
			return (Message) messageConstructor.newInstance(lineNumber, columnIndices, columnNames, new Flag(flagValue), fieldValue, validValue);
		} catch (Exception e) {
			throw new MessageException("Error while constructing message object from rebuild code", e);
		}
	}
	
	/**
	 * Reconstruct a set of Message objects from a semi-colon separated list of rebuild code strings
	 * @param codes The rebuild codes
	 * @return The corresponding Message objects
	 * @throws MessageException If any of the rebuild codes cannot be made into Message objects
	 */
	public static List<Message> getMessagesFromRebuildCodes(String codes) throws MessageException {

		List<Message> messages = new ArrayList<Message>();

		if (null != codes) {
			String codeString = codes.trim();
			if (codeString.length() > 0) {
				String[] splitCodes = codeString.split(";");
				for (int i = 0; i < splitCodes.length; i++) {
					messages.add(new RebuildCode(splitCodes[i]).getMessage());
				}
			}
		}
		
		return messages;
	}
	
	/**
	 * Convert a set of Message objects into a comma-separated list of rebuild code strings
	 * @param messages The messages
	 * @return The rebuild codes
	 * @throws MessageException If any messages cannot be converted to rebuild codes
	 */
	public static String getRebuildCodes(List<Message> messages) throws MessageException {
		StringBuffer codes = new StringBuffer();
		for (int i = 0; i < messages.size(); i++) {
			codes.append(new RebuildCode(messages.get(i)).getCode());
		}
		
		return codes.toString();
	}
	
	/**
	 * Extract the individual components from a Rebuild Code string
	 * @param code The code string
	 * @return The code components
	 */
	private List<String> extractComponents(String code) {
		
		List<String> fields = new ArrayList<String>();

		int currentIndex = 0;
		StringBuilder fieldValue = new StringBuilder();
		
		while (currentIndex < code.length()) {

			// Skip backslashes
			if (code.charAt(currentIndex) != '\\') {
				
				if (code.charAt(currentIndex) == '_') {
					if (code.charAt(currentIndex - 1) == '\\') {
						fieldValue.append('_');
					} else {
						fields.add(fieldValue.toString());
						fieldValue = new StringBuilder();
					}
				} else {
					fieldValue.append(code.charAt(currentIndex));
				}
			}
			
			currentIndex++;
		}
		
		fields.add(fieldValue.toString());
		
		return fields;
	}
}
