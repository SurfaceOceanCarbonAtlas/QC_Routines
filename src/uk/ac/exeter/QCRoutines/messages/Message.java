package uk.ac.exeter.QCRoutines.messages;

import java.lang.reflect.Constructor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.TreeSet;

import uk.ac.exeter.QCRoutines.data.DataColumn;

/**
 * Holds message generated by QC routines.
 * 
 * Note that all concrete implementations of this class MUST provide a constructor of
 * int, int, String, Flag, String, String.
 * 
 * This allows message objects to be constructed programatically from the most
 * basic components.
 * This will be be checked whenever one of the constructors is invoked.
 * 
 * @author zuj007
 *
 */
public abstract class Message {
	
	public static final int NO_COLUMN_INDEX = -999;
	
	public static final int NO_LINE_NUMBER = -999;

	protected TreeSet<Integer> columnIndices;
	
	protected TreeSet<String> columnNames;
	
	private Flag flag;
	
	protected int lineNumber;
	
	protected String fieldValue;
	
	protected String validValue;
	
	public Message(int lineNumber, TreeSet<Integer> columnIndices, TreeSet<String> columnNames, Flag flag, String fieldValue, String validValue) {
		this.lineNumber = lineNumber;
		this.columnIndices = columnIndices;
		this.columnNames = columnNames;
		this.flag = flag;
		this.fieldValue = fieldValue;
		this.validValue = validValue;
		
		// Note that we don't need to check the basic constructor here, because this is it!
	}
	
	public Message(int lineNumber, int columnIndex, String columnName, Flag flag, String fieldValue, String validValue) throws MessageException {
		this.lineNumber = lineNumber;

		columnIndices = new TreeSet<Integer>();
		columnIndices.add(columnIndex);

		columnNames = new TreeSet<String>();
		columnNames.add(columnName);

		this.flag = flag;
		this.fieldValue = fieldValue;
		this.validValue = validValue;
		
		checkBasicConstructor(getClass());
	}
	public Message(int lineNumber, DataColumn dataColumn, Flag flag, String validValue) throws MessageException {
		this.lineNumber = lineNumber;
		
		columnIndices = new TreeSet<Integer>();
		columnIndices.add(dataColumn.getColumnIndex());

		columnNames = new TreeSet<String>();
		columnNames.add(dataColumn.getName());
		
		this.flag = flag;
		this.fieldValue = dataColumn.getValue();
		this.validValue = validValue;
		
		checkBasicConstructor(getClass());
	}
	
	public Message(int lineNumber, DataColumn dataColumn, Flag flag, String fieldValue, String validValue) throws MessageException {
		this.lineNumber = lineNumber;
		
		columnIndices = new TreeSet<Integer>();
		columnIndices.add(dataColumn.getColumnIndex());

		columnNames = new TreeSet<String>();
		columnNames.add(dataColumn.getName());

		this.flag = flag;
		this.fieldValue = fieldValue;
		this.validValue = validValue;
		
		checkBasicConstructor(getClass());
	}
	
	/**
	 * Returns the line number for which this message was raised.
	 * @return The line number for which this message was raised.
	 */
	public int getLineNumber() {
		return lineNumber;
	}
	
	/**
	 * Returns the column indices for which this message was raised.
	 * @return The column indices for which this message was raised.
	 */
	public TreeSet<Integer> getColumnIndices() {
		return columnIndices;
	}

	/**
	 * Returns the column names for which this message was raised
	 * @return the name of the column(s) for which this message was raised.
	 */
	public TreeSet<String> getColumnNames() {
		return columnNames;
	}
	
	/**
	 * Returns the list of column names as a String, with names separated by '/'
	 * @return The list of column names
	 */
	public String getColumnNamesAsString() {
		StringBuffer result = new StringBuffer();
		
		int nameCount = 0;
		for (String columnName : columnNames) {
			nameCount++;
			result.append(columnName);
			if (nameCount < columnNames.size()) {
				result.append('|');
			}
		}
		
		return result.toString();
	}

	/**
	 * Returns the flag of the message
	 * @return The flag of the message
	 */
	public Flag getFlag() {
		return flag;
	}
	
	/**
	 * Create the {@link MessageKey} object for this message,
	 * to be used in storing the message.
	 * 
	 * @return The {@link MessageKey} object for this message 
	 */
	public MessageKey generateMessageKey() {
		return new MessageKey(columnIndices, getClass());
	}
	
	public abstract String getFullMessage();
	
	public abstract String getShortMessage();
	
	public RebuildCode getRebuildCode() throws MessageException {
		return new RebuildCode(this);
	}
	
	public String getFieldValue() {
		return fieldValue;
	}
	
	public String getValidValue() {
		return validValue;
	}
	
	public String toString() {
		return getFullMessage();
	}
	
	public boolean equals(Object o) {
		boolean equals = true;
		
		if (!(o instanceof Message)) {
			equals = false;
		} else {
			Message compare = (Message) o;
			if (!compare.columnIndices.equals(columnIndices) ||
					!compare.columnNames.equals(columnNames) ||
					!compare.flag.equals(flag) ||
					compare.lineNumber != lineNumber ||
					!compare.fieldValue.equals(fieldValue) ||
					!compare.validValue.equals(validValue)) {
				equals = false;
			}
		}
		
		return equals;
	}
	
	protected static void checkBasicConstructor(Class<? extends Message> messageClass) throws MessageException {
		
		boolean hasConstructor = true;
		
		try {
			Constructor<?> constructor = messageClass.getConstructor(int.class, TreeSet.class, TreeSet.class, Flag.class, String.class, String.class);
			
			// Check that the Set is for Integers
			Type[] constructorGenericTypes = constructor.getGenericParameterTypes();
			if (constructorGenericTypes.length != 6) {
				hasConstructor = false;
			} else {
				if (!(constructorGenericTypes[1] instanceof ParameterizedType)) {
					hasConstructor = false;
				} else {
					Type[] actualTypeArguments = ((ParameterizedType) constructorGenericTypes[1]).getActualTypeArguments();
					if (actualTypeArguments.length != 1) {
						hasConstructor = false;
					} else {
						Class<?> typeArgumentClass = (Class<?>) actualTypeArguments[0];
						if (!typeArgumentClass.equals(Integer.class)) {
							hasConstructor = false;
						}
					}
				}
			}
		} catch (NoSuchMethodException e) {
			hasConstructor = false;
		}
		
		if (!hasConstructor) {
			throw new MessageException("Message class " + messageClass.getName() + " is missing the basic constructor");
		}
	}
}
